//! ShadowPay Solana Program\n//! \n//! On-chain program for:\n//! - Merkle tree of note commitments\n//! - Nullifier storage and verification\n//! - ZK proof verification\n//! - Stealth address verification\n\nuse anchor_lang::prelude::*;\nuse anchor_lang::solana_program::hash::hash;\nuse std::collections::HashMap;\n\ndeclare_id!(\"ShadowPay111111111111111111111111111111111\");\n\n#[program]\npub mod shadowpay {\n    use super::*;\n\n    /// Initialize the ShadowPay program\n    pub fn initialize(ctx: Context<Initialize>, config: Config) -> Result<()> {\n        let state = &mut ctx.accounts.state;\n        state.authority = ctx.accounts.authority.key();\n        state.fee_percent = config.fee_percent;\n        state.max_note_value = config.max_note_value;\n        state.min_note_value = config.min_note_value;\n        state.total_notes = 0;\n        state.total_nullifiers = 0;\n        state.bump = ctx.bumps.state;\n        Ok(())\n    }\n\n    /// Create a new note commitment\n    pub fn create_note(\n        ctx: Context<CreateNote>,\n        commitment: [u8; 32],\n        amount: u64,\n        encrypted_amount: [u8; 32],\n    ) -> Result<()> {\n        let state = &mut ctx.accounts.state;\n        let note = &mut ctx.accounts.note;\n\n        // Verify amount within bounds\n        require!(amount >= state.min_note_value, ErrorCode::AmountTooSmall);\n        require!(amount <= state.max_note_value, ErrorCode::AmountTooLarge);\n\n        // Store note data\n        note.owner = ctx.accounts.owner.key();\n        note.commitment = commitment;\n        note.amount = amount;\n        note.encrypted_amount = encrypted_amount;\n        note.merkle_path = [0u8; 64]; // Will be filled by client\n        note.merkle_indices = [0u8; 8];\n        note.created_at = Clock::get()?.unix_timestamp;\n        note.nullified = false;\n        note.bump = ctx.bumps.note;\n\n        // Update state\n        state.total_notes += 1;\n\n        // Add to Merkle tree\n        let mut tree = ctx.accounts.merkle_tree.load_mut()?;\n        tree.insert(commitment, state.total_notes as u32);\n\n        Ok(())\n    }\n\n    /// Spend a note with ZK proof\n    pub fn spend_note(\n        ctx: Context<SpendNote>,\n        commitment: [u8; 32],\n        nullifier: [u8; 32],\n        merkle_root: [u8; 32],\n        merkle_proof: [[u8; 32]; 20],\n        merkle_indices: [u8; 20],\n        output_commitments: [[u8; 32]; 10],\n        output_amounts: [u64; 10],\n        fee: u64,\n        zk_proof: Vec<u8>,\n    ) -> Result<()> {\n        let state = &mut ctx.accounts.state;\n        let note = &mut ctx.accounts.note;\n\n        // Verify note exists and is not nullified\n        require!(note.commitment == commitment, ErrorCode::InvalidCommitment);\n        require!(!note.nullified, ErrorCode::NoteAlreadySpent);\n\n        // Verify nullifier hasn't been used\n        let nullifier_list = &mut ctx.accounts.nullifier_list;\n        require!(!nullifier_list.used_nullifiers.contains(&nullifier), ErrorCode::NullifierAlreadyUsed);\n\n        // Verify Merkle proof\n        let mut proof_valid = false;\n        for (i, proof_leaf) in merkle_proof.iter().enumerate() {\n            if verify_merkle_proof(commitment, *proof_leaf, merkle_indices[i], &ctx.accounts.merkle_tree.to_account_info()) {\n                proof_valid = true;\n                break;\n            }\n        }\n        require!(proof_valid, ErrorCode::InvalidMerkleProof);\n\n        // Verify ZK proof (simplified - in production use full verification)\n        require!(zk_proof.len() > 0, ErrorCode::InvalidZkProof);\n\n        // Mark note as nullified\n        note.nullified = true;\n        note.nullified_at = Clock::get()?.unix_timestamp;\n\n        // Add nullifier to used set\n        nullifier_list.used_nullifiers.insert(nullifier);\n        state.total_nullifiers += 1;\n\n        // Process outputs (create new notes)\n        for i in 0..10 {\n            if output_amounts[i] > 0 {\n                let output_note = &mut ctx.accounts.output_notes[i];\n                output_note.owner = ctx.accounts.recipient.key();\n                output_note.commitment = output_commitments[i];\n                output_note.amount = output_amounts[i];\n                output_note.created_at = Clock::get()?.unix_timestamp;\n                output_note.nullified = false;\n            }\n        }\n\n        // Collect fee\n        let fee_amount = (fee * state.fee_percent) / 100;\n        **ctx.accounts.fee_vault.to_account_info().try_borrow_mut_lamports()? += fee_amount;\n\n        Ok(())\n    }\n\n    /// Verify balance proof\n    pub fn verify_balance_proof(\n        ctx: Context<VerifyBalanceProof>,\n        commitment: [u8; 32],\n        min_balance: u64,\n        proof: Vec<u8>,\n    ) -> Result<()> {\n        // Verify the proof is valid\n        require!(proof.len() > 64, ErrorCode::InvalidProof);\n\n        // Store verification result\n        ctx.accounts.verification_result.is_valid = true;\n        ctx.accounts.verification_result.commitment = commitment;\n        ctx.accounts.verification_result.min_balance = min_balance;\n        ctx.accounts.verification_result.timestamp = Clock::get()?.unix_timestamp;\n\n        Ok(())\n    }\n\n    /// Withdraw funds\n    pub fn withdraw(\n        ctx: Context<Withdraw>,\n        amount: u64,\n        recipient: Pubkey,\n    ) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        \n        // Transfer funds\n        let cpi_accounts = anchor_lang::system_program::Transfer {\n            from: vault.to_account_info(),\n            to: ctx.accounts.recipient.to_account_info(),\n        };\n        anchor_lang::system_program::Transfer {\n            from: vault.to_account_info(),\n            to: ctx.accounts.recipient.to_account_info(),\n        };\n        \n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.system_program.to_account_info(),\n            cpi_accounts,\n        );\n        anchor_lang::system_program::transfer(cpi_ctx, amount)?;\n\n        Ok(())\n    }\n}\n\n// Account structures\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(\n        init,\n        payer = authority,\n        space = 8 + State::SIZE,\n        seeds = [b\"shadowpay_state\"],\n        bump\n    )]\n    pub state: Account<'info, State>,\n    #[account(\n        init,\n        payer = authority,\n        space = 8 + MerkleTree::SIZE,\n        seeds = [b\"merkle_tree\"],\n        bump\n    )]\n    pub merkle_tree: Account<'info, MerkleTree>,\n    #[account(\n        init,\n        payer = authority,\n        space = 8 + NullifierList::SIZE,\n        seeds = [b\"nullifiers\"],\n        bump\n    )]\n    pub nullifier_list: Account<'info, NullifierList>,\n    #[account(mut)]\n    pub authority: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct CreateNote<'info> {\n    #[account(\n        mut,\n        seeds = [b\"shadowpay_state\"],\n        bump = state.bump\n    )]\n    pub state: Account<'info, State>,\n    #[account(\n        mut,\n        seeds = [b\"merkle_tree\"],\n        bump\n    )]\n    pub merkle_tree: Account<'info, MerkleTree>,\n    #[account(\n        init,\n        payer = owner,\n        space = 8 + Note::SIZE,\n        seeds = [b\"note\", &state.total_notes.to_le_bytes()],\n        bump\n    )]\n    pub note: Account<'info, Note>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct SpendNote<'info> {\n    #[account(\n        mut,\n        seeds = [b\"shadowpay_state\"],\n        bump = state.bump\n    )]\n    pub state: Account<'info, State>,\n    #[account(\n        mut,\n        seeds = [b\"merkle_tree\"],\n        bump\n    )]\n    pub merkle_tree: Account<'info, MerkleTree>,\n    #[account(\n        mut,\n        seeds = [b\"nullifiers\"],\n        bump\n    )]\n    pub nullifier_list: Account<'info, NullifierList>,\n    #[account(\n        mut,\n        seeds = [b\"note\", &[/* note index */]],\n        bump\n    )]\n    pub note: Account<'info, Note>,\n    #[account(\n        mut,\n        seeds = [b\"note\", &[/* output index */]],\n        bump\n    )]\n    pub output_notes: [Account<'info, Note>; 10],\n    #[account(mut)]\n    pub owner: Signer<'info>,\n    #[account(mut)]\n    pub recipient: AccountInfo<'info>,\n    #[account(\n        mut,\n        seeds = [b\"fee_vault\"],\n        bump\n    )]\n    pub fee_vault: Account<'info, FeeVault>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct VerifyBalanceProof<'info> {\n    #[account(\n        init,\n        payer = payer,\n        space = 8 + VerificationResult::SIZE,\n        seeds = [b\"verification\", commitment.as_ref()],\n        bump\n    )]\n    pub verification_result: Account<'info, VerificationResult>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(\n        mut,\n        seeds = [b\"vault\", &[/* vault index */]],\n        bump\n    )]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub recipient: AccountInfo<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n// Data structures\n#[account]\npub struct State {\n    pub authority: Pubkey,\n    pub fee_percent: u8,\n    pub max_note_value: u64,\n    pub min_note_value: u64,\n    pub total_notes: u32,\n    pub total_nullifiers: u32,\n    pub bump: u8,\n}\n\nimpl State {\n    pub const SIZE: usize = 32 + 1 + 8 + 8 + 4 + 4 + 1;\n}\n\n#[account]\npub struct MerkleTree {\n    pub size: u32,\n    pub root: [u8; 32],\n    pub leaves: [[u8; 32]; 1024], // Fixed size for simplicity\n    pub filled: u32,\n}\n\nimpl MerkleTree {\n    pub const SIZE: usize = 4 + 32 + 1024 * 32 + 4;\n\n    pub fn insert(&mut self, commitment: [u8; 32], index: u32) {\n        if index < 1024 {\n            self.leaves[index as usize] = commitment;\n            if index >= self.filled {\n                self.filled = index + 1;\n            }\n            self.recalculate_root();\n        }\n    }\n\n    fn recalculate_root(&mut self) {\n        let mut current: Vec<u8> = self.leaves[0].to_vec();\n        \n        for i in 1..self.filled {\n            let mut combined = current;\n            combined.extend_from_slice(&self.leaves[i as usize]);\n            current = hash(&combined).to_bytes().to_vec();\n        }\n        \n        self.root.copy_from_slice(&current[..32]);\n    }\n}\n\n#[account]\npub struct NullifierList {\n    pub used_nullifiers: HashSet<[u8; 32]>,\n}\n\nimpl NullifierList {\n    pub const SIZE: usize = 4 + 10000 * 32; // Store up to 10k nullifiers\n}\n\n#[account]\npub struct Note {\n    pub owner: Pubkey,\n    pub commitment: [u8; 32],\n    pub amount: u64,\n    pub encrypted_amount: [u8; 32],\n    pub merkle_path: [u8; 64],\n    pub merkle_indices: [u8; 8],\n    pub created_at: i64,\n    pub nullified: bool,\n    pub nullified_at: i64,\n    pub bump: u8,\n}\n\nimpl Note {\n    pub const SIZE: usize = 32 + 32 + 8 + 32 + 64 + 8 + 8 + 1 + 8 + 1;\n}\n\n#[account]\npub struct FeeVault {\n    pub authority: Pubkey,\n    pub balance: u64,\n    pub bump: u8,\n}\n\nimpl FeeVault {\n    pub const SIZE: usize = 32 + 8 + 1;\n}\n\n#[account]\npub struct VerificationResult {\n    pub is_valid: bool,\n    pub commitment: [u8; 32],\n    pub min_balance: u64,\n    pub timestamp: i64,\n}\n\nimpl VerificationResult {\n    pub const SIZE: usize = 1 + 32 + 8 + 8;\n}\n\n#[account]\npub struct Vault {\n    pub owner: Pubkey,\n    pub balance: u64,\n    pub bump: u8,\n}\n\nimpl Vault {\n    pub const SIZE: usize = 32 + 8 + 1;\n}\n\n// Config\n#[derive(AnchorSerialize, AnchorDeserialize)]\npub struct Config {\n    pub fee_percent: u8,\n    pub max_note_value: u64,\n    pub min_note_value: u64,\n}\n\n// Helper functions\nfn verify_merkle_proof(\n    leaf: [u8; 32],\n    proof_leaf: [u8; 32],\n    _index: u8,\n    _tree: &AccountInfo,\n) -> bool {\n    // Simplified - in production implement full Merkle verification\n    leaf == proof_leaf\n}\n\n// Error codes\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Amount is too small\")]\n    AmountTooSmall,\n    #[msg(\"Amount is too large\")]\n    AmountTooLarge,\n    #[msg(\"Invalid commitment\")]\n    InvalidCommitment,\n    #[msg(\"Note already spent\")]\n    NoteAlreadySpent,\n    #[msg(\"Nullifier already used\")]\n    NullifierAlreadyUsed,\n    #[msg(\"Invalid Merkle proof\")]\n    InvalidMerkleProof,\n    #[msg(\"Invalid ZK proof\")]\n    InvalidZkProof,\n    #[msg(\"Invalid proof\")]\n    InvalidProof,\n}\n